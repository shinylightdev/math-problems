import { Operand } from './Operand';


/**
 * Individual math problem to solve. Generated by ProblemSet. 
 *
 * @class Problem
 */
export class Problem {
  constructor(operator: string, operands: Operand[]) {
    this.Operator = operator;
    this.Operands = operands;
    this.WrongAttempts = [];
    this.OperandsGenerated = Operand.resolveOperands(this.Operands);
    this.Answer = this.getAnswer();
    this.Expression = this.generateExpression();
  }

  public Operator: string; // + - / *  
  public Answer?: number;
  public WrongAttempts: number[];
  public Expression: string;
  
  private Operands: Operand[];
  private OperandsGenerated: number[];


  /**
   * Generates an expression to be displayed on screen. 
   *
   * @returns {string}
   * @memberof Problem
   */
  public generateExpression(): string {
    let problem = "";
    let operands = this.OperandsGenerated;
    problem = operands.join(this.Operator);
    return problem;
  }


  /**
   * Gets sum of all the operands. 
   *
   * @returns {number}
   * @memberof Problem
   */
  public getSum(): number {
    // Using reduce() on array to get sum of entire list.
    const sum = this.OperandsGenerated.reduce((a, b) => a + b, 0);    
    return sum;
  }

  /**
   * Gets product of all the operands.
   *
   * @returns {number}
   * @memberof Problem
   */
  public getProduct(): number {
    
    // We initialize (the param) to one so that the multiplication sequence
    // stars with 0. If it was 0, then everything would be zero.
    const product = this.OperandsGenerated.reduce((a, b) => a * b, 1);    
    return product;
  }
  
  
  /**
   * Attempts to get division of all operands. Divide in sequential 
   * order. If denominator is zero, will return Infinity. If numerator and
   * denominator are both 0, then will return NaN. Additionally, it returns 
   * rounded to nearest 2 decimal.
   *
   * @returns {string}
   * @memberof Problem
   */
  public getQuotient(): number {        
      // We initialize (the param) to one so that the multiplication sequence
      // stars with 0. If it was 0, then everything would be zero.
      let quotient = this.OperandsGenerated.reduce((a, b) => a / b);
      quotient = Math.round(
                  (quotient + Number.EPSILON) * 100 // for more precision, use Number.EPSILON
                ) / 100;                
                    
    return quotient;
  }  
  

  /**
   * Gets subraction. Makes the first operand be positive, and the rest negative operands.
   *
   * @returns {number}
   * @memberof Problem
   */
  public getSubtraction(): number {   
    let subtractionOperands = this.OperandsGenerated.map( (operand, index) => {  
      let returnOperand: number;      
      
      // Let's keep the first operand (element in array), positive.
      if (index === 0) {
        returnOperand = operand;
      }
      // Let's flip the signs on the rest.
      else {
        returnOperand = operand - (operand * 2);
      }        
      return returnOperand;
    });
    
    // Now let's add everything up. 
    let subtraction = subtractionOperands.reduce((a, b) => a + b, 0);    
    
    return subtraction;
    
  }
  
  
  /**
   * Gets the answer using the proper arimetic function (get(), getSubtraction()). 
   *
   * @returns {(number | undefined)}
   * @memberof Problem
   */
  public getAnswer(): number | undefined {
    let answer: number | undefined;
    if (this.Operator === "+") {
      answer = this.getSum();
    }
    else if (this.Operator === "-") {
      answer = this.getSubtraction();
    }    
    else {
      // something here.
    }
    return answer;
  }
}